# Week 1 Basic Syntax

-> Day 1- Javascript 1: Variable, Operators, Assignments
-> Comments
Comments are lines of code that are ignored intentionally. They are a great way to make notes for yourself and people reading your code.
There are two types of comments in Javascript
1. // this is an inline comment
2. /**/ this is a multi-line comment
Good commenting can help communicate the intent of your code, both for others and your future self.

-> Variables
One of the most fundamental characteristics of a programmining language is the type of data it supports. These are the type of values that can be manipulated 
and represented in a programmining language.
Javascript allows you to work with primitive data types
1. Numbers e.g. 123, 120.50, etc.
2. Strings of text e.g. "This is a string".
3. Boolean e.g. true or false.
Javascript also defines two trivial data types: Null and Undefined.
JavaScript supports a composit data type known as an Object.
JavaScript does not make a distinction between Integers and Floating-point values. All members in JavaScript are represented as floating-point values.
Variables allow computers to store and manipulate data in a dynamic fashion. They do this by using a "label" to point to the data rather than using the data itself.
Any of the 8 data types may be stored in a variable 
Variables in JavaScript are declared using the "Var" keyword and you can declare multiple variables using this keyword.
1. Single declaration e.g  var name;
2. multiple declaration e.g. var name, money;
Storing a value in a variable is called "Variable Initialization". You can initialize a variable at the time of creation or at anytime when you need to use the variable
Use the "Var" keyword only for declaratin or initialization. You should not declare the same variable twice.
JavaScript is an untyped language. This means it can hold a value of any data type. The value type of a variable can change during execution of the program 
and Javascript takes care of it automatically.

-> Strings
A string is a sequence of characters that may consist of letters, numbers, or synmbols. String in JS are primitive data times and immutable.
As Strings are the way we display and work with text and text is our main way of communicating and understanding through computers, Strings are
one of the most fundamental concepts of programming to be familiar with.

 Creating and viewing the output of strings 
In JS, there are 3 ways of writing strings. They can be single quotes(''), They can be double quotes ("") or backticks(''). the type used must match on both sides
however it is possible that all 3 styles be used in the same script.
Strings using double quotes  and single quotes are effectively the same, there is no convention or official preference for single or double
quoted strings. keeping consistent with project program files is all that matters 
  e.g. 'This uses single quotes'
  e.g. "This uses double quotes"

-> Functions
A funtion is a group of reusable code which can be called anywhere in your program.This eliminates the need of writing the same code again and again
Functions allow a programmer to divide a program into a small number of manageable functions
JS supports all the necessary features to wwrite modular code using functions. Functions such as alert() and write() have been written in core JS.
JS allows us to write our own functions as well.

  Funtion Definition
The most common way to define a function in JS is by using the function keyword, followed by a unique name, a list of parameters, and a statement block surrounded by curly braces
  Syntax
function functionName(parameter-list){
  //statements
}
-> Booleans
Booleans are values that can be only one of two things: True or False
Anything "On" or "Off", "Yes" or "No" or temporary is a usually good fit for a boolean. It's useful to store booleans in variables to keep
track of their values and change them over time.

-> Type Conversion
Most of the time, operators and functions automatically convert the values given to them to the right time e.g. alert automatically  converts any
value to a string to show it. Mathematical operations convert values to numbers. There are also cases when we need to explicitly convert a value to
the expected type.

-> String Conversion
String Conversion happens when we need the string form of a value. 
e.g. alert(value) does it to show the value
We can also call the string(value) function to convert a value to a string 
e.g. value = string(value)

-> Numeric Conversion
Numeric conversion happens in mathematical funtiopns and expressions automatically
e.g. alert("6"/"2"); //3  Strings are converted to numbers
We can use the number(value) functionto explicitly convert a value to a number
e.g. let num = number(str)
Explicit conversion is usually required when we read a value from a string-based source like a text form but expect a number to be entered
If a string is not a valid number, the result of such a conversionis NaN
e.g. let age = number("an Arbitrary string instead of a number");
alert(age);
  Numeric conversion rules:
Value                  Becomes
-Undefined             NaN
-Null                  0
-True or False         1 and 0
-String                white space removed

-> Boolean Conversion
It happens in logical operations, but can also be perfomed explicitly with a call to boolean(value)
The converion rule: 
  >Values that are intuitively "empty" like 0, an empty string, null, undefined and Nan become false
  Other values become true

-> Formatting numbers
JS number format: main tips
> Several JS number format methods are offered with this language that you can use to manipulate numeric values.
> Each number method returns a new value instead of changing the one being used for the method.
> Every JS number format method may be used on any type of number including literals, variables, expressions.
 ->These are the go-to methods while working with numeric values:
  >number(); Return number converted from its argument
  >parseFloat(); Parse its argument and return a float
  >parseInt(); Parse its argument and return an integer
  >toString(); Return number as string
  >toExponential(); Return string with numberrounded and written with exponential notations.
  >toFixed(); Return string with rounded and written using a specified number of decimals
  >toPrecision(); Return string with a number written with a specified length.
  >valueOf(); Return number as a number

-> The Document Object Model and JavaScript Syntax
The Document Object Model is an Application Programming Interface(API) for HTML and XML documents. it does two things for web developers
 > Provides a structural representation of the document.
 > Defines the way that the structure is to be accessed from script
The JS syntax has to do with objects, to access an object, property or method.
its reference must include every object that contains it, separated by a dot. This is called the "dot syntax"

-> Object
  > A JS Object is any scriptable HTML element, that is, any HTML element within a document that may be accessed through the JS language.
  > Outside the context of a web page are core ojects. These objects are not associated with HTML elements, but with the language itself
    then there are home made objects. core objects and home made objects are both associated with the JS object model.
  > The following are some of the JS Objects:
    - window
    - document
    - form
    - image
-> Property
 > Objects have properties, which you can think of as characteristics of an object. 
   A JS property has a similar relationship to the object it belogs to that an HTML tag attribute has to the tag that it contains it.
 > There is one major exception: JS properties can also be objects. the object-property relationship is more like the relationship an <option>
    tag has to the <select> tagthat contains it, but in JS, Theres is no difference in how you prefer to a plain old property and a 
    property that is also an object.
 > A document, although contained by the window and therefore a property of the window object, is also considered an object. The same is true for a form and
   an image, they are properties of the document object but also properties themselves. The rule for the dual properties is this: a property is also an object
   if that property has its own properties and methods. it is best to think of objects with properties as objects.
 
-> Method 
 > Methods are actions that can be applied directly to objects. methods cause a boring old HTML document to react to the end-user. This results in a 
   meaningful experience for the end-user otherwise would be completely one-sided.
-> Method parameters 
 > Methods are signified by parenthesis immediately following their name e.g. alert(); These parenthesis sometimes hold values called parameters, which are 
   required by some methods.
 > A parameter is simply information needed by a method to perform its task. for instance, the alert() method pops up an alert box without a parameter, the 
   alert method will generate a dialog box alert(), which is meaningless. But with a parameter, the alert method will generate a dialog box alert("Hello World")
   which communicates a massasge to the end user.
 -> Here are a few Javascript methods
    - alert() causes an alert dialog box to appear over the pages that launched it.
    - write() writes content to a page
    - focus() causes the mouse cursor to be inserted into a form element

 -> Core APIs in the DOM 
   > Document and Window objects are the objects whhose interfaces you generally use most often in DOM programming. The window object represents something like
    the browser and the document object is the root of the document itself. Elements inherits from the generic node interface and together these two interface
    provide many of the methods and properties you use on individual elements.
  > The following is a brief list of common APIs in web and XML page scripting using the DOM
    - document.getElementById(id)
    - document.getElementsByTagName(name)
    - document.createElement(name)
    - parentNode.appendChild(node)
    - element.innerHTML
    - element.style.left
    - element.setAttribute
    - element.getAttribute
    - element.addEventListner
    - window._content
    - window.onload
    - window.dump()
    - window.scrollTo()

 -> Functions
   > A Funtion is a subprogram designed to perform a particular task. A function will only execute if and only when it has been called. Values can be passed
     into functions and used within that function as well. All funtions have a return value, otherwise they become undefined. A function is an object(HTML element
     with properties and methods)
  > A function declaration is as follows
       function name(parameters){//statements}

 -> Calling one function from another function
   > Code inside a function behaves just like anywhere else. This means you can call one function from inside another function, this allows you to nest functions
     so that you can create separate functions, which each perform a specific task, and then run them together as a complete process.
 
 -> Creating objects with user-defined functions
   > Javascript is based on objects: the window is an object, links are objects, forms are objects, even Netscape itself is an object. Using objects can help
     make programming easier and more streamlined. You can extend the use of objects in Javascript by making your own. the process uses functions in a slightly modified
     way.

 -> Making a new object entails two steps: 
   > Define the object in a user-defined function
   > Use the new keyword to create(or instantiate) the object with a call to the object function.
     e.g. ret = new makeSimpleObject();
          function makeSimpleObject(){}

 -> Defining new properties to already-made objects
   > After an object has been created you can assign a value to it, but instead of just assigning a value to the object itself, you should define a new property 
     for the object, and assign a value to the property. To create a new property and assign a value to it, simply wite a variable expression like this:
     e.g. myObject.property = value
   > myObject is the name of the user-defined object
   > property is the name of the property you want to create
   > Value is the value you want to assign.

 -> Defining properties when you create the object
   > Another method of defining properties for objects is to include the property names in the object function. You can use this technique to simultaneously 
     create a new object and define the property values
     e.g. customer = new makeCustomer("Fred", "123 main street", "555-1212");
          alert(customer.name);
          
          function makeCustomer(name, address, phone){
          this.name = name;
          this.address = address;
          this.phone = phone;
        }
   -> Each this statement assigns a property to the current object, which is the one being created in the makeCustomer object function. Three parameters are
      passed to the object statement: the customer's name, address, and phone number. These parameters are used to define the contents of the three properties.
   -> Javascript imposes no limitations on the number of properties you can assign to an object. To include as customer object, jut do this:
      e.g. customer = new makeCustomer("Fred", "123 main street", "555-1212")
          customer.salutation = "Mr. ";

   -> Note that other objects you create with the makeCustomer object function will have just these three base properties but this object for Fred will have
      an additional property for the salutation. properties added later do not affect other objects created with the same object function.

  -> Operators
   > JS has the following types of operators, this section describes the operators and contains information about operator precedence
     - Assignment Operators
     - Comparison Operators
     - Arithmatic Operators
     - Bitwise Operators
     - Logical Operators
     - String Operators
     - Conditional(ternary) Operators
     - Comma Operators
     - Unary Operators
     - Relational Operators

  > JS has both binary and unary operators and one special ternary operator, the Conditional operator. 
    > A binary operator require two operands, one before the operator and one after the operator.
      e.g. operand1 + operand2
           3 + 4 or x*y
    > A Unary operator requires a single operand, either before or after the operator:
      e.g. operator operand or operand operator

 -> Assignment Operator
  > Return value and chaining
   - Like most expressions, assignments like x=y have a return value, it can be retrieved by e.g. assigning the expression or logging it to the console.
   - An Assignment operator assigns a value to its left operand based on the value of its right operand. that is x=y assigns the value of y to x.
   - There are also compound assignment operators that are shorthand for the operations listed in the following table.

 -> Compound Assignment Operator
   - const z = (x=y); //or equivalent; const z = x = y
   - console.log(z); // log the return value of the assignment x=y
   - console.log(x=y); // or log the return value directly
   > The return value matches the expression to the right of the "=" sign in the "meaning" column of the table above. that means that (x=y) returns y,
     (x += y) returns the resulting sum x+y, (x**=y) returns the resulting power x**y, and so on.
   > In the case of logical assignments, (x&&=y), (x||=y) and (x??=y), the return value is that of the logical operation without the assignment so x&&y, x||y and x??y.
   > The return values are always based on the operands values before operation.
   > When chaining these expressions, each assignment is evaluated right-to-left.
    - e.g. w=z=x=y is equal to w = (z = (x =)) or x=y; z=y; w=y
    - e.g. z += x*=y is equivalent to z+=(x*=y) or tmp = x*y; x*=y; z+=tmp (except without the tmp)

-> Destructuring
 > The destructuring assignment syntax is a JS expression that makes it possible to extract data from
    arrays or objects using a syntax that mirrors the construction of array and object literals.
    e.g. var foo = ['one', 'two', 'three']
    // without destructuring
    var one = foo[0];
    var two = foo[1];
    var three = foo[2];
   // with destructuring
    var [one, two, three] = foo;

-> Comparison Operators
 > A comparison operator compares its operands and returns a logical value based on whether the
   comparison is true. The operands can be numerical, string, logical, or object values. Strings are 
   compared based on standard lexicographical ordering, using unicode values. 
   If the two operands are not the same data types, JS attempts to convert them to appropriate types
   for comparison. This behavior generally results in comparing the operands numerically. The sole
   exceptions to type conversion within comparisons include "===" and "!==" operators, which perform
   strict equality and inequality comparisons. These operators do not attempt to convert the operands
   to compatible types before checking equality.

-> Arithmetic Operators
 > An arithmetic operator takes numerical values(either literals or variables) as their operands
   and returns a single numerical value.
 > The standard arithmetic operators are addition(+), subtraction(-), multiplication(*) and division(/).
 > These  operators work as they do in most other programming languages when used with floating point numbers.

-> Bitwise Operators
 > a bitwise operator treats their operands as a set of 32 bits (zeros and ones), rather than decimal, hexadecimal,
   or octal numbers. Bitwise operators perfom their operations on such binary representation, but the return standard
   JS numerical values

-> Bitwise Logical Operators
 > The operands are converted to 32bit intergers and expressed by a series of zeros and ones(bits).numbers with
   more than 32bits get most of their significant bits discarded.
   e.g. var x = [0,1,2,3,4,5,6,7,8,9];
        var a = [x,x,x,x,x];
      for (var i=0, j=9; i<=j; i++, j--);
      console.log('a[' + i + '][' + j + ']= ' + a[i][j]);
 > Each bit in the first operand is paired with the corresponding bit in the second operand
 > The operator is applied to each pair of bits, and the results is constructed bitwise.

-> Bitwise Shift Operators
 > Nitwise shift operators take two operands: the first is a quantity to be shifted and the second
   specifies the number of bits positions by which the first operand is to be shifted. the direction
   of the operation is controlled by the operator used.
 > Shift operators convert their operands to 32-bit integers and return a result of the same type as
   the left operand.

-> Logical Operators
 > Logical operators are typically used with boolean values: When they are, they return a boolean value
   However, the && and || operators return the value of one of the specified operands, so if these
   operators are used with non-boolean values, the may return a non-boolean value.
 > Examples of expressions that can be converted to false are those that evaluate to null, 0, NaN, empty 
   string, or undefined.

-> Short-circuit evaluation
 > As logical expressions are evaluated left-to-right, they are tested for possible "short-circuit" evaluation using the following rules:
  - false&&anything is short-circuit evaluated to false
  - true||anything is short-circuit evaluated to true
 > The rules of logic guarantee that these evaluations are always correct. Note that the anything is not evaluated
   so any side effects of doing so do not take effect.
 > In mordern code you can use the new nullish coalescing operator(??) that works like ||, but it only returns the seconds
   expression, when the first one is "nullish", i,e null or undefined. it is a better alternative
   to provide defaults when values like '' or 0 are valid for the first expression, too.

-> String Operators
 > In addition to the comparison operators, which can be used on string values, the concatenation operator (+) concatenates
   two string values together, returning another string that is the union of the two operand strings.
 > The Shorthand assignment operator += can also be used to concatenate strings.

-> Conditional(ternary) Operator
 > The Conditional operator is the only JS operator that takes three operands. The operator can have one of two values 
   based on a condition. The syntax is:
    e.g. condition ? val1: val2
 > if condition is true, the operator has the value of val1. otherwise it has the value of val2.
   you can use the conditional operator anywhere you would use a standard operator.

-> Comma Operator
 > The comma operator evaluates both of its operands and returns the value of the last operand. 
   This operator is primarily used inside a for loop, to allow multiple variables to be updated each time through the loop.
    it is regarded bad style to use it elsewhere, when it is not necessary. Often two separate statements can and should be used instead.
    e.g. var x = [0,1,2,3,4,5,6,7,8,9];
           var a = [x,x,x,x,x];
         for (var i=0, j=9; i<=j; i++, j--);
         console.log('a[' + i + '][' + j + ']= ' + a[i][j]);

-> Unary Operator
 > A Unary operation is an operation with only one operand
 > The Delete operator deletes an objects property. The syntax is:
   e.g. delete object.property;
        delete object[propertyKey]
        delete objectName[index];
        delete property;
 > Since arrays are just objects, its technically possible to delete elements from them. When you delete an array property, the array
   length is not affected and elements are not re-indexed. to achieve that behaviour, it is much better to just overwrite the element with
   the value undefined. To actually manipulate the array, use the various array methods such as splice.

-> TypeOf
 > The typeOf operator returns a string indicating the type of the unevaluated operand. operand is the string, variable, keyword or object for
   which the type is to be returned. the parentheses are optional

-> void
 > The void operator specifies an expression to be evaluated without returning a value. expression is a JS expression to evaluate
 > The parentheses surrounding the expression are optional, but it is good style to use them
   e.g. void (expression) or void expression.

-> Relational Operator
 > A relational operator compares its operand and returns a boolean value based on whether the comparison is true.
 > The in operator returns true if the specified property is in the specified object. the syntax is:
   e.g. propNameOrNumber in objectName
 > Where propNameOrNumber is a string, numeric, or symbol expression representing a property name or array index and objectName is the name of an object.

-> instanceOf
 > The instanceOf operator returns true if the specified object is of the specified object type. The syntax is:
   e.g. objectName instanceOf objectType
 > where objectName is the name of the object to compare to objectType, and the objectType is an object type such as date or array.
 > Use instanceOf when you need to confirm the type of an object at runtime.

-> Operator Precedence
 > The precedence of operators determines the order they are applied when evaluating an expression. You can override operator precedence by using parenthesis

-> Event Bubbling
 > The event starts at the element that triggered it, then, it bubbles up to each of its parent element until it reaches the document.
   Any listeners on any of those parent elements would get triggered as it bubbles up. causing all the events to occur on the page possibly slowing down your application.
 > e.g. forms, the event would bubble up to the parent form, then any containers or divs the form was in, then the body, then html element, then the document, then the window.

-> Event Delegation
 > Event delegation is a technique for listening to event where you delegate a parent element as the listner for all the events that happen inside it.
 > So instead of adding event listener to each button you would just add and event listener to the parent element and target the child element

-> Regular Expressions
 > A regular expression is a sequence of characters that forms a search pattern. 
 > The search pattern can be used for text search and text replace operations
 > A regular expressioncan be a single character, or a more complicated pattern.
 > Regular expressions can be used to perform all types of text search and text replace operations

-> JS Methods and "this" keyword
 -> Accessing Object Methods
  > You can access an object method using a dot notation. the syntax is:
    e.g objectName.methodKey()
 > You can access a method by calling an objectName and a key for that method along with(). And you can access property only by
   calling an objectName and a key.

-> JS Built-in Methods
 > In IS, there are many built-in methods
  e.g. let number = '23.32'
       let result = parseInt(number)
       console.log(result); // 23

-> JS this keyword
 > To access a property of an object from within a method of the same object, you need to use the this keyword.
 > In order to access the properties of an object, this keyword is used following with .andkey
 > Note: In JS, this keyword when used with the objects method refere to the object. this is bound to an object
 > However, the function inside of an object can access it variable in a similar was as a normal function would.

# Day 3 - Javascript Forms
-> Switch Statements
 > The switch statement is used to perform different actions based on different conditions
 > Use the switch statement to select one of many code blocks to be executed
 > Syntax:   switch(expression){
                  case x:
                  // code block
                     break;
                  case y:
                  // code block
                     break;
                  default;
                  // code block  
 }
 > The switch expression is evaluated once.
 > The value of the expression is compared with the values of each case
 > If there is a match, the associated block of code is executed
 > If there is no match, the default code block is executed
 > The Break keyword
   - When JS reaches a break keyword, it breaks out of the switch block
   - This will stop the execution of inside the block
   - It is not necessary to break the last case in a switch block. the block breakes there anyway.
 > The Default keyword
   - The default keyword specifies the code to run if there is no case match:
   - If default is not the last case in the switch block, remember to end the default case with a break.
 > Common Code blocks
   - Sometimes you will want different switch cases to use the same code.
   - Switching Details
      If multiple cases matches a case value, the first case is selected.
      If no matching cases are found, the program continues to the default label
      if no default label is found, the program coninues to the statement(s) after the switch
 > Strict Comparison
   - Switch cases use strict comparison (===)
   - The values must be of the same type to match
   - A strict comparison can only be true if the operands are of the same type.

# Week 3 Event Handling
# day 1 JavaScript Events
-> String Operations
 > Creating Strings
 > Strings are like words or sentences that we can use in our computer programs. 
   We can create strings in different ways. We can just write them with single or double quotes, 
   or we can use a special kind of quotes called backticks. 
   Sometimes we can also use a special code called a constructor to create strings.
> Once we have a string, we can do different things with it. 
  We can look at each letter in the string, and there are two ways to do that. 
  We can use a method called 'charAt()', or we can think of the string as a bunch of letters 
  in a list and find a letter by its position in the list.
> In some cases, we might want to compare strings to see if they are the same or 
  which one comes first. In other programming languages, there is a special function 
  called 'strcmp()' for this, but in JavaScript, we can just use the less-than and greater-than 
  symbols.
> Sometimes we want to compare strings without worrying about whether the letters are uppercase 
  or lowercase. In those cases, we can use a special method called 'localeCompare()', 
  or we can write our own function.
> It's important to know that there is a difference between String objects and 
  primitive string values. We can convert between them if we need to.
> Sometimes when we use certain functions or evaluate code, we need to be careful
  if we are using a String object or a primitive string. But most of the time, 
  we don't need to worry about it. We can always change a String object to a primitive 
  string if we want to."

-> On-Event Handlers
 > Event handlers are like special instructions that we can give to objects on a webpage. 
   These objects can be things you can click on, like buttons or links, or even things on the page 
   itself. Events are things that happen, like when you click on a button or press a key on the 
   keyboard.
 > We can tell objects how to react when these events happen by using event handlers. 
   Event handlers have names that match the event they are meant for. 
   For example, if we want to do something when a button is clicked, we use the onclick event handler.
 > There are different ways to specify an event handler for an event. We can write the code 
   directly in the HTML using a special attribute, like onclick="return handleClick(event);". 
   Or we can write the code in JavaScript and set it as a property of the object, 
   like document.getElementById("mybutton").onclick = function(event) { ... }.
 > It's important to know that each object can only have one event handler for a specific event. 
   But that event handler can do many different things. If we want to have multiple event handlers 
   for the same event, we can use a special function called addEventListener().
 > When an event handler is called, it receives information about the event, like what was 
   clicked or which key was pressed. Inside the event handler, the "this" keyword refers to the 
   object that the event handler belongs to. The event handler can also decide whether to 
   cancel the event or let it continue.
 > Sometimes people use the term "event handler" to refer to any function or object that listens 
   to events. But it can also specifically mean the way we register event listeners using on... 
   attributes or properties.
 > Overall, event handlers help us make our webpages interactive and control what happens when
   things are clicked or pressed.

-> Event Handler specific Rules
 > Certain event handlers have specific rules that apply to them. These rules state that
   they must be supported by all HTML elements except for the body and frameset elements. 
   These event handlers can be used both as content attributes and IDL (Interface Definition Language)
   attributes. Additionally, they must be supported by all Document objects and Window objects as 
   IDL attributes. For Window objects, the corresponding event handler content attributes and IDL 
   attributes should also be exposed on all body and frameset elements owned by that Window object's 
   Documents.
 > Here is a list of event handlers that can be used in HTML5 elements, Document objects, 
   and Window objects:
 - onabort: Triggered when an event is aborted, such as when the browser stops downloading media
   data before it's fully downloaded.
 - oncancel: Handles the cancel event.
 - oncanplay: Invoked when the browser can start playing media but hasn't started yet due 
   to buffering.
 - oncanplaythrough: Indicates that if the media started playing now, it could be played to the
   end without further buffering.
 - onchange: Triggered when the user changes an object, such as filling out a form field and 
   then clicking elsewhere.
 - onclick: Invoked when the user clicks on an object.
 - oncuechange: Handles the cuechange event.
 - ondblclick: Triggered when the user double-clicks on an object.
 - ondurationchange: Invoked when the duration of the media changes.
 - onemptied: Triggered when a media resource suddenly becomes empty, for example, due to a 
   network error.
 - onended: Invoked when the media has reached its end.
 - oninput: Handles the input event.
 - oninvalid: Handles the invalid event.
 - onkeydown: Triggered when a key is pressed over an element.
 - onkeypress: Invoked when a key is pressed over an element and then released.
 - onkeyup: Triggered when a key is released over an element.
 - onloadeddata: Invoked when the browser can render the media data at the current playback 
   position for the first time.
 - onloadedmetadata: Invoked when the browser determines the duration and dimensions of the 
   media resource.
 - onloadstart: Triggered when the browser starts loading the media resource.
 - onmousedown: Invoked when the cursor moves over the object and the mouse or pointing device 
   is pressed down.
 - onmouseenter: Triggered when the cursor enters the outer element (not the inner element).
 - onmouseleave: Invoked when the cursor leaves the element.
 - onmousemove: Triggered when the cursor moves while hovering over an object.
 - onmouseout: Invoked when the cursor moves off the object.
 - onmouseover: Triggered when the cursor moves over the object.
 - onmouseup: Invoked when the mouse or pointing device is released after being pressed down.
 - onmousewheel: Triggered when the mouse wheel is rotated.
 - onpause: Invoked when the media resource has been paused.
 - onplay: Triggered when the media resource starts playback.
 - onplaying: Indicates that playback has begun.
 - onprogress: Indicates that the browser is fetching media data.
 - onratechange: Invoked when the playback rate has changed.
 - onreset: Handles the reset event.
 - onseeked: Invoked when the seeking attribute changes to false.
 - onseeking: Invoked when the seeking attribute changes to true and the seek operation takes 
   enough time for the event to be fired.
 - onselect: Triggered when some or all of the contents of an object are selected.
 - onshow: Handles the show event.
 - onstalled: Invoked when the browser is trying to fetch media data, but the data has stalled.
 - onsubmit: Triggered when the user submits a form.
 - onsuspend: Indicates that the browser is intentionally not currently fetching media data but
   has not yet downloaded the entire media resource.
 - ontimeupdate: Invoked when the media's current playback position changes.
 - ontoggle: Triggered when a details element is opened or closed.
 - onvolumechange: Invoked when either the volume or muted attribute changes.
 - onwaiting: Indicates that the next frame of the media is not yet available.
-> These event handlers help developers control and respond to various actions and changes happening
   on web pages.

# Day 2 Dynamic JavaScript Techniques
-> Dynamic HTML
 > Imagine you have a box, and you can make it look different by using special markers and
   stickers. That's like HTML, where you can create web pages and make them look nice.
   But sometimes, you want the box to change when something happens. 
   For example, maybe you want it to become bigger or change color when someone clicks on it. 
   That's where CSS and JavaScript come in.
 > CSS is like the special markers and stickers. It helps you change how the box looks. 
   You can change the color, the size, and even the font of the text inside the box.
 > JavaScript is like a set of special instructions. It helps you make the box do things 
   when something happens, like when you click on it or move your mouse over it. 
   You can make the box move around the page or even change what it says.
 > To make these changes, you can use different methods. You can either change the class of the 
   box, which is like using a different set of markers and stickers to give it a new look. 
   Or you can use the style property, which is like using specific markers and stickers to change 
   its appearance directly.
 > JavaScript functions are like special recipes. They tell the computer what to do with the box.
   You can either tell the function to work with a specific box by using its special name, or
   you can tell it to work with any box by giving it the name of the box you want to change.
 > Sometimes, you can even use events to help you find the box you want to change. 
   Events are like little signals that tell you when something happens. You can use these 
   signals to figure out which box was clicked on or where the mouse is, and then you can change 
   that box.
 > So, by using CSS and JavaScript together with HTML, you can make web pages that are not 
   only nice to look at but also can do cool things when you interact with them!"

-> Date Object
 > "The Date object in JavaScript is like a special container that can hold the current date 
  and time. It has special tools inside it that can help us do different things with dates.
  
 > When we create a new Date object without giving it any instructions, it automatically 
   sets itself to the current date and time on the computer. It looks at the settings on the 
   computer to figure out what the current date and time are.
   
 > To understand how the Date object works, let's pretend we have a special box called 'dateBox'. 
   We can put the current date and time inside this box. Today is Wednesday, October 18th in London.
   So, if we look inside the 'dateBox', we will see the current date, time, and the place where 
   we are (London, GMT)."
 > The date and time are shown to us in a special way so that we can read and understand them.
   But JavaScript, which is a special language, understands the date in a different way.
   It uses a special number called a "timestamp" that tells us how many milliseconds have 
   passed since a very long time ago. It's like counting how many seconds have passed since 
   a specific moment. We can find out this special number using a tool called the 
   "getTime() method".
 > The big number that we see when we look at the timestamp actually represents the same 
   date as before, which is October 18th, 2017.
 > There is a special time called "Epoch time" or "zero time" that starts at a specific 
   moment: January 1st, 1970, at exactly midnight, in a place called Universal Time (UTC). 
   This moment is represented by the date and time "01 January, 1970 00:00:00 Universal Time 
   (UTC)" and it has a special number called a "timestamp," which is 0.
 > We can test this in a web browser by making a new box called a "variable" and putting 
   inside it a new Date that starts at the timestamp of 0.
 > In the early days of programming, a special way of measuring time called "Epoch time" 
   was chosen as a standard for computers. This is the same method that JavaScript uses to
   understand time. It's important to know about two things: the "timestamp," which is a special
   number, and the "date string," which is a way of writing dates and times in a human-readable
   format. Depending on the settings and what we want to do with a computer program, we might
   use either the timestamp or the date string.
 > So far, we have learned how to create a new Date object using the current time or using
   a timestamp. But there are actually four different ways to create a new Date in JavaScript. 
   Besides the default current time and the timestamp, we can also use a date string 
   (which is like writing the date in words) or specify specific dates and times.

-> Retrieving the date with get
 > After we have a date, we can use special tools called "methods" to access different parts 
   of the date. These methods are already built into JavaScript. When we use these methods, 
   they will give us back specific numbers that represent each part of the date, like the year,
   month, day, and so on. It's important to note that these methods will give us the date and
   time based on the place where we are (our local timezone). Each of these methods starts with
   the word "get" and will give us the corresponding number. 
 > The built-in Date methods that begin with get allow us to access date components that
   return the number associated with what we are retrieving from the instantiated object.

-> Retrieving the date with set
 > For each of the "get" methods we learned about earlier, there is a corresponding "set" 
   method. While the "get" methods retrieve specific components from a date, the "set" 
   methods allow us to change or modify those components. The table below provides details about
   the "set" methods available in the Date object:

   Date/Time          Method                Range  Example
   Year               setFullYear()         YYYY   1970
   Month              setMonth()            0-11   0 = January
   Day (of the month) setDate()             1-31   1 = 1st of the month
   Day (of the week)  setDay()              0-6    0 = Sunday
   Hour               setHours()            0-23   0 = midnight
   Minute             setMinutes()          0-59   
   Second             setSeconds()          0-59
   Millisecond        setMilliseconds()     0-999
   Timestamp          setTime()             Milliseconds since Epoch time

 > We can use these "set" methods to change one or more components of a date. 
   For example, we can modify the year of a variable called "birthday" to be 1997 instead of 1980.
   In the example above, when we access the "birthday" variable, we will see the updated year 
   as part of the output.
   The "set" methods provided by JavaScript allow us to modify different parts of a Date object.

-> Date methods with UTC
  > The "get" methods we talked about earlier retrieve the components of a date based on 
    the user's local timezone settings. However, if you want more control over dates and times,
    you can use the "getUTC" methods. These methods are exactly like the "get" methods, 
    but they calculate the time based on the UTC (Coordinated Universal Time) standard, 
    which is a global time standard. Below is a table that shows the UTC methods available in the
    JavaScript Date object.

    Date/Time          Method                 Range    Example  
    Year               getUTCFullYear()       YYYY     1970  
    Month              getUTCMonth()          0-11     0 = January  
    Day (of the month) getUTCDate()           1-31     1 = 1st of the month  
    Day (of the week)  getUTCDay()            0-6      0 = Sunday  
    Hour               getUTCHours()          0-23     0 = midnight  
    Minute             getUTCMinutes()        0-59
    Second             getUTCSeconds()        0-59  
    Millisecond        getUTCMilliseconds()   0-999  

 > To test the difference between local and UTC get methods, we can run the following code.
 > When you run this code, it will show you the current hour in your local timezone and also 
   in the UTC timezone. If you happen to be in the UTC timezone, the numbers displayed will 
   be the same.
 > UTC is helpful because it provides a standard reference for time that is used internationally.
   This can be useful in keeping your code consistent across different timezones, especially
   if it's important for what you're developing.

-> Adding and Subtracting from a given date
 > The Date setters are like special buttons that you can use to change different parts of 
   a date. For example, one of the setters called setDays() expects a number between 1 and 31 
   to represent the day. But here's an interesting thing: if you try to use a number that is 
   too big or too small, the date will automatically roll over to the next or previous month.
 > Let's say you try to set the day to 30 in the month of February. Since February doesn't 
   have 30 days, the date will roll over to March.
 > This rolling over happens not just for the day, but for other parts of the date too. 
   It even knows about leap years!
 > Whether this rolling over rounds the date or not depends on what you want. Sometimes you
   might want to include a part of a day, and sometimes you might not. It's up to you to decide 
   if you want it to round or not.

# Day 3 Keyboard, Form, and Document/Window Events
-> When you press or let go of a key on the keyboard, a special event called a 
   "keyboard event" is triggered. Similarly, when you interact with a form on a website, like
   clicking inside a text box or changing its value, a "form event" is triggered. 
   Additionally, there are events related to the whole document or the browser window, 
   such as when a page finishes loading or when you resize the window.

-> These events are super helpful because they allow you to make your websites more interactive
   and engaging. They give you the power to create interesting things that respond to the 
   user's actions.

-> Keyboard Events
-> The Keydown Event(onKeydown)
 > The keydown event occurs when the user presses down a key on the keyboard. 
   You can handle the keydown event with the onkeydown event handler. 
   The following example will show you an alert message when the keydown event occurs.
   e.g. <input type= "text" onkeydown="alert('You have pressed a key inside text input')">
        <textarea onkeydown="alert('You have pressed a key inside textarea!')"></textarea>

-> The KeyUp Event(onkeyup)
 > The keyup event occurs when the user releases a key on the keyboard. 
   You can handle the keyup event with the onkeyup event handler. 
   The following example will show you an alert message when the keyup event occurs.
   e.g. <input type= "text" onkeyup="alert('You have pressed a key inside text input')">
        <textarea onkeyup="alert('You have pressed a key inside textarea!')"></textarea>

-> The Keypress Event(onkeypress)
 > The "keypress" event happens when you press a key on the keyboard that corresponds to 
   a specific character. Not all keys generate a "keypress" event, though. 
   Keys like Ctrl, Shift, Alt, Esc, Arrow keys, and others won't trigger a "keypress" event,
   but they will trigger "keydown" and "keyup" events.
 > To respond to the "keypress" event, you can use a special code called an "event handler" 
   designed specifically for "keypress" events, called "onkeypress". 
   In the following example, an alert message will be displayed when the "keypress" event occurs.
   e.g. <input type= "text" onkeypress="alert('You have pressed a key inside text input')">
        <textarea onkeypress="alert('You have pressed a key inside textarea!')"></textarea>

-> Form Events
 > 
